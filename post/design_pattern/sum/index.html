<!doctype html>
<html lang="en-us">
  <head>
    <title>设计模式6大原则 // zgq blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.60.0-DEV" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://edqwer.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设计模式6大原则"/>
<meta name="twitter:description" content="单一职责原则（Single Responsibility Principle）  定义：就一个类而言， 应该仅有一个引起它变化的原因。
 理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。
总结：一个类只承担一个职责
开放封闭原则（Open Close Principle）  定义：类、模块、函数等应该是可以拓展的，但是不可修改。
 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。
总结：对软件实体的改动，最好用扩展而非修改的方式。
里氏替换原则（Liskov Substitution Principle）  定义：所有引用基类的地方必须能透明地使用其子类的对象。
 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。
总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。
注：它是开闭原则的具体实现手段之一，它的核心原理是抽象 里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在OOP中，继承的优缺点相当明显，有点如下： （1）代码重用，减少创建类成本，每个子类拥有父类的属性和方法； （2）子类和父类基本相似，但又与父类有所区别； （3）提高代码的可拓展性。 继承的缺点： （1）继承是侵入性的，只要继承就必须拥有弗雷的所有属性和方法； （2）可能造成子类代码的冗余、灵活性降低，因为子类必须拥有弗雷的属性和方法。 开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展的开发，对修改的关闭效果。
接口隔离原则（InterfaceSegregation Principles）  定义：一个类对另一个类的依赖应该建立在最小的接口上。
 理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。
总结：不要对外暴露没有实际意义的接口。
注：最小化， 减少依赖从而降低变更的风险。 建立单一接口，不要建立庞大臃肿接口；尽量细化接口，接口中方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类调用。 （1）接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，一定要适度。 （2）为依赖接口的类定制服务，只暴露给调用的类需要的方法，它不需要的方法则隐蔽起来。只有专注得为一个模块提供定制服务，才能建立最小的依赖关系。 （3）提高内聚，减少对外交互。接口方法尽量少用public修饰。接口是对外的承诺，承诺越少对系统开发越有利，变更风险也会越少。 以上（单一职责、开闭原则、里氏替换、接口隔离、依赖倒置）五个原则被Bob大叔在21世纪早期定义为SOLID原则。作为面向对象编程的5个基本原则，当这些原则被一起使用时，它们使得一个软件系统更清晰、简单，最大程度地拥抱变化。
依赖倒置原则（Dependence Inversion Principle）  高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
 理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。
总结：面向接口编程，提取出事务的本质和共性。
注：关系到系统的可拓展性、拥抱变化的能力、开闭原则 java中抽象指接口或抽象类，两者都不能直接被实例化的；细节就是实现类，实现接口或者集成抽象类而产生的也就细节，也就是可以可以加上yige 关键字new产生的对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在java中表现就是，模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么久会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可拓展性。
迪米特原则（Law of Demeter）也称最少知识原则  定义：一个软件实体应当尽可能少地与其他实体发生相互作用。
 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。
总结：一定要做到：低耦合、高内聚。
注：通过引入一个合理的第三者降低现有对象之间的耦合度。 一个类应该对自己需要耦合或者调用的类知道最少， 类的内部如何实现与调用者或者依赖关系越密切，耦合度越大，当一个类发生变化时，对另一个类的影响也越大。 （1）在类的划分上，应当尽量创建松耦合的类。类之间的耦合度约低，就越有利于服用。一个处于松耦合中的类一旦被修改，则不会对关联的类造成太大的波及。 （2）在类的机构设计上， 每一个类都应当尽量降低其成员变量和成员函数的访问权限。 （3）在对其他类的引用上， 一个类对其他对象的引用应当降到最低。"/>

    <meta property="og:title" content="设计模式6大原则" />
<meta property="og:description" content="单一职责原则（Single Responsibility Principle）  定义：就一个类而言， 应该仅有一个引起它变化的原因。
 理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。
总结：一个类只承担一个职责
开放封闭原则（Open Close Principle）  定义：类、模块、函数等应该是可以拓展的，但是不可修改。
 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。
总结：对软件实体的改动，最好用扩展而非修改的方式。
里氏替换原则（Liskov Substitution Principle）  定义：所有引用基类的地方必须能透明地使用其子类的对象。
 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。
总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。
注：它是开闭原则的具体实现手段之一，它的核心原理是抽象 里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在OOP中，继承的优缺点相当明显，有点如下： （1）代码重用，减少创建类成本，每个子类拥有父类的属性和方法； （2）子类和父类基本相似，但又与父类有所区别； （3）提高代码的可拓展性。 继承的缺点： （1）继承是侵入性的，只要继承就必须拥有弗雷的所有属性和方法； （2）可能造成子类代码的冗余、灵活性降低，因为子类必须拥有弗雷的属性和方法。 开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展的开发，对修改的关闭效果。
接口隔离原则（InterfaceSegregation Principles）  定义：一个类对另一个类的依赖应该建立在最小的接口上。
 理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。
总结：不要对外暴露没有实际意义的接口。
注：最小化， 减少依赖从而降低变更的风险。 建立单一接口，不要建立庞大臃肿接口；尽量细化接口，接口中方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类调用。 （1）接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，一定要适度。 （2）为依赖接口的类定制服务，只暴露给调用的类需要的方法，它不需要的方法则隐蔽起来。只有专注得为一个模块提供定制服务，才能建立最小的依赖关系。 （3）提高内聚，减少对外交互。接口方法尽量少用public修饰。接口是对外的承诺，承诺越少对系统开发越有利，变更风险也会越少。 以上（单一职责、开闭原则、里氏替换、接口隔离、依赖倒置）五个原则被Bob大叔在21世纪早期定义为SOLID原则。作为面向对象编程的5个基本原则，当这些原则被一起使用时，它们使得一个软件系统更清晰、简单，最大程度地拥抱变化。
依赖倒置原则（Dependence Inversion Principle）  高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
 理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。
总结：面向接口编程，提取出事务的本质和共性。
注：关系到系统的可拓展性、拥抱变化的能力、开闭原则 java中抽象指接口或抽象类，两者都不能直接被实例化的；细节就是实现类，实现接口或者集成抽象类而产生的也就细节，也就是可以可以加上yige 关键字new产生的对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在java中表现就是，模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么久会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可拓展性。
迪米特原则（Law of Demeter）也称最少知识原则  定义：一个软件实体应当尽可能少地与其他实体发生相互作用。
 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。
总结：一定要做到：低耦合、高内聚。
注：通过引入一个合理的第三者降低现有对象之间的耦合度。 一个类应该对自己需要耦合或者调用的类知道最少， 类的内部如何实现与调用者或者依赖关系越密切，耦合度越大，当一个类发生变化时，对另一个类的影响也越大。 （1）在类的划分上，应当尽量创建松耦合的类。类之间的耦合度约低，就越有利于服用。一个处于松耦合中的类一旦被修改，则不会对关联的类造成太大的波及。 （2）在类的机构设计上， 每一个类都应当尽量降低其成员变量和成员函数的访问权限。 （3）在对其他类的引用上， 一个类对其他对象的引用应当降到最低。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://edqwer.github.io/post/design_pattern/sum/" />
<meta property="article:published_time" content="2020-01-16T22:51:11+08:00" />
<meta property="article:modified_time" content="2020-01-16T22:51:11+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://edqwer.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>zgq blog</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">设计模式6大原则</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 16, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h4 id="单一职责原则-single-responsibility-principle">单一职责原则（Single Responsibility Principle）</h4>

<blockquote>
<p>定义：就一个类而言， 应该仅有一个引起它变化的原因。</p>
</blockquote>

<p>理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。</p>

<p>总结：一个类只承担一个职责</p>

<h4 id="开放封闭原则-open-close-principle">开放封闭原则（Open Close Principle）</h4>

<blockquote>
<p>定义：类、模块、函数等应该是可以拓展的，但是不可修改。</p>
</blockquote>

<p>理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。</p>

<p>总结：对软件实体的改动，最好用扩展而非修改的方式。</p>

<h4 id="里氏替换原则-liskov-substitution-principle">里氏替换原则（Liskov Substitution Principle）</h4>

<blockquote>
<p>定义：所有引用基类的地方必须能透明地使用其子类的对象。</p>
</blockquote>

<p>理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。</p>

<p>总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。</p>

<p>注：它是开闭原则的具体实现手段之一，它的核心原理是抽象
里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在OOP中，继承的优缺点相当明显，有点如下：
（1）代码重用，减少创建类成本，每个子类拥有父类的属性和方法；
（2）子类和父类基本相似，但又与父类有所区别；
（3）提高代码的可拓展性。
继承的缺点：
（1）继承是侵入性的，只要继承就必须拥有弗雷的所有属性和方法；
（2）可能造成子类代码的冗余、灵活性降低，因为子类必须拥有弗雷的属性和方法。
开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展的开发，对修改的关闭效果。</p>

<h4 id="接口隔离原则-interfacesegregation-principles">接口隔离原则（InterfaceSegregation Principles）</h4>

<blockquote>
<p>定义：一个类对另一个类的依赖应该建立在最小的接口上。</p>
</blockquote>

<p>理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。</p>

<p>总结：不要对外暴露没有实际意义的接口。</p>

<p>注：最小化， 减少依赖从而降低变更的风险。
建立单一接口，不要建立庞大臃肿接口；尽量细化接口，接口中方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类调用。
（1）接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，一定要适度。
（2）为依赖接口的类定制服务，只暴露给调用的类需要的方法，它不需要的方法则隐蔽起来。只有专注得为一个模块提供定制服务，才能建立最小的依赖关系。
（3）提高内聚，减少对外交互。接口方法尽量少用public修饰。接口是对外的承诺，承诺越少对系统开发越有利，变更风险也会越少。
以上（单一职责、开闭原则、里氏替换、接口隔离、依赖倒置）五个原则被Bob大叔在21世纪早期定义为SOLID原则。作为面向对象编程的5个基本原则，当这些原则被一起使用时，它们使得一个软件系统更清晰、简单，最大程度地拥抱变化。</p>

<h4 id="依赖倒置原则-dependence-inversion-principle">依赖倒置原则（Dependence Inversion Principle）</h4>

<blockquote>
<p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>

<p>理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。</p>

<p>总结：面向接口编程，提取出事务的本质和共性。</p>

<p>注：关系到系统的可拓展性、拥抱变化的能力、开闭原则
java中抽象指接口或抽象类，两者都不能直接被实例化的；细节就是实现类，实现接口或者集成抽象类而产生的也就细节，也就是可以可以加上yige 关键字new产生的对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在java中表现就是，模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么久会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可拓展性。</p>

<h4 id="迪米特原则-law-of-demeter-也称最少知识原则">迪米特原则（Law of Demeter）也称最少知识原则</h4>

<blockquote>
<p>定义：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
</blockquote>

<p>理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。</p>

<p>总结：一定要做到：低耦合、高内聚。</p>

<p>注：通过引入一个合理的第三者降低现有对象之间的耦合度。
一个类应该对自己需要耦合或者调用的类知道最少， 类的内部如何实现与调用者或者依赖关系越密切，耦合度越大，当一个类发生变化时，对另一个类的影响也越大。
（1）在类的划分上，应当尽量创建松耦合的类。类之间的耦合度约低，就越有利于服用。一个处于松耦合中的类一旦被修改，则不会对关联的类造成太大的波及。
（2）在类的机构设计上， 每一个类都应当尽量降低其成员变量和成员函数的访问权限。
（3）在对其他类的引用上， 一个类对其他对象的引用应当降到最低。</p>

<p>总体来说23种设计模式分为三大类：</p>

<p>创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>

<p>结构型模式（7种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>

<p>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
